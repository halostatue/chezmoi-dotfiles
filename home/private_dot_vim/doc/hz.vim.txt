*hz.vim.txt*	Collected functions and commands for my vimrc
Austin Ziegler <halostatue@gmail.com>                        *Hz.vim* *hz.vim*

==============================================================================
CONTENTS                                                     *hz.vim-contents*
  1. Introduction........................................|hz.vim-introduction|
  2. Functions..............................................|hz.vim-functions|
  3. Functional Functions................................|hz.vim-fn-functions|
  4. Compatibility......................................|hz.vim-compatibility|
  5. Licence..................................................|hz.vim-licence|

==============================================================================
INTRODUCTION                                             *hz.vim-introduction*

Hz.vim is a collection of functions and commands that power Austin Ziegler's
vim configuration. The latest version has been rewritten to use |vim9script|
so they are only compatible with Vim 9 or later.

==============================================================================
FUNCTIONS                                                   *hz.vim-functions*

hz#platform()                                                   *hz#platform()*
hz.Platform(): string                                           *hz.Platform()*

  Returns a string representing the underlying platform, resulting in one of
  `windows`, `cygwin`, `mac`, or `unix`.

hz#is({type})                                                         *hz#is()*
hz.Is({type}: string): bool                                           *hz.Is()*

  Returns `true` if the tested {type} value is defined as true. Supported
  values for {type} are:

      Type              Condition~
      windows           |has| win16, win32, or win64
      cygwin            |has| win32unix
      mac               not windows or cygwin, |has| mac, macunix, gui_macvim,
                        or `uname` is `darwin` and does not have `xdg-open`
      macgui            is mac and has gui_running
      sudo              $SUDO_USER is set and is not $USER
      tmux              $TMUX is set

  Unrecognized values will always return `false`.

hz#valid_function({value})                                *hz#valid_function()*
hz.IsValidFunction({value}: any): bool                   *hz.IsValidFunction()*

  Report whether the {value} is a valid function (|t:v_func|) or function
  name (|t:v_string|). The function name may be a bare name (`fn`) or have
  parentheses at the end (`fn()`).

hz#mkpath({path}, [force])                                       *hz#mkpath()*
hz.MKpath({path}: string, forcE: bool = false)                   *hz.Mkpath()*

  Make {path}, prompting unless [force] is provided. Except for the prompting,
  equivalent to |mkdir()| with the `'p'` option.

hz#isotime([time])                                              *hz#isotime()*
hz.Isotime(time: number = null): string                         *hz.Isotime()*

  Portably produce a proper ISO 8601/RFC3339 timestamp. If [time] is not
  provided, the current time will be used.

hz#try([dict], [default], {Func}, [args])                           *hz#try()*
hz.Try(args: list<any>): any                                        *hz.Try()*

  NOTE: The preferred form of calling this function is with the autoload
  function form, as it uses variable arguments. The Vim 9 script import
  version must use arguments in an array.

  Try to call the given {Func} with an optional dictionary, default, and
  arguments. >

      hz#try('fugitive#statusline')
      hz#try(function('fugitive#statusline'))
      hz.Try(['fugitive#statusline'])
      hz.Try([function('fugitive#statusline')])
<

  If {Func} is a dictionary function (and not a partial function reference),
  the `self` must be provided with the [dict] parameter. >

      hz#try({}, 'dict.Func')
      hz.Try([{}, 'dict.Func'])
<

  A [default] value may be provided before the function reference, if it is
  inside of a list. >

      hz#try(['default'], 'F')
      hz.Try([['default'], 'F'])
<

  Arguments are passed after the function name or reference. >

      hz#try(['default'], 'F', 1, 2, 3)
      hz.Try([['default'], 'F', 1, 2, 3])
<

  This function is originally by Tim Pope as part of Flagship.

  [default] is `null` if omitted.
  [dict] is `{}` if omitted.
  [args] is `[]` if omitted.

hz#in({haystack}, {needle})                                          *hz#in()*
hz.In(haystack: any, needle: any): bool                              *hz.In()*

  Answers if {needle} can be found in the provided {haystack} which may be
  a string, list, or dictionary.

  If {haystack} is a string, {needle} must also be a string. {haystack} is
  searched with |stridx()|.

  If {haystack} is a list, it is searched with |index()|.

  If {haystack} is a dictionary, it is searched with |index()| over the
  |values()|.

  If {haystack} is any other type, the return value is false.

hz#trim_leading({string}, [pattern])                        *hz#trim_leading()*
hz.TrimLeading(string: string, pattern: string = '\_s'): string
                                                             *hz.TrimLeading()*

  Trims leading [pattern] from {string}. [pattern] defaults to '\_s', the
  regex for whitespace and newlines.

hz#trim_trailing({string}, [pattern])                      *hz#trim_trailing()*
hz.TrimTrailing(string: string, pattern: string = '\_s'): string
                                                            *hz.TrimTrailing()*
  Trims trailing [pattern] from {string}. [pattern] defaults to '\_s', the
  regex for whitespace and newlines.

hz#trim({string}, [pattern])                                       *hz#trim()*
hz.Trim(string: string, pattern: string = '\_s'): string           *hz.Trim()*

  Trims both leading and trailing [pattern] from {string}. [pattern] defaults
  to '\_s', the regex for whitespace and newlines.

hz#execute_in_place({command})                          *hz#execute_in_place()*
hz.ExecuteInPlace(cmd: string)                            *hz.ExecuteInPlace()*

  Executes {command} while saving and restoring the window state.

hz#execute_with_saved_search({command})        *hz#execute_with_saved_search()*
hz.ExecuteWithSavedSearch(cmd: string)            *hz.ExecuteWithSavedSearch()*

  Executes {command} while saving and restoring the most recent saved search
  history and the window state.

hz#clean_whitespace({line1}, {line2})                   *hz#clean_whitespace()*
hz#CleanWhitespace(line1: any, line2: any)               *hz.CleanWhitespace()*

  Clean trailing whitespace from the range provided. Uses
  |hz#execute_with_saved_search()| underneath, so search and window state are
  restored after execution.

hz#get_setting({name}, [default])                            *hz#get_setting()*
hz.GetSetting(name: string, default: any = null)             *hz.GetSetting()*

  Gets the value of a variable setting {name}, checking for a buffer override
  then a global value. That is, {name} will be checked from |b:|, then |g:|.
  A [default] value may be provided. >

  hz#get_setting('foo', false)
  get(b:, 'foo', get(g:, 'foo', false))
<


hz#get_motion({motion})                                       *hz#get_motion()*
hz.GetMotion(motion: string): string                           *hz.GetMotion()*

  Execute the normal mode {motion} and return the text that it marks. For this
  to work, the {motion} must include a visual mode key (`V`, `v`, or `gv`).

  Both the 'z' register and the original cursor position will be restored
  after the text is yanked.

hz#switch_window({bufname})                                *hz#switch_window()*
hz.SwitchWindow(bufname: string)                            *hz.SwitchWindow()*

  Programmatically jump to the window identified by {bufname}.

hz#range_uniq([ignore_ws])                                    *hz#range_uniq()*
hz.RangeUniq(line1: number, line2: number, ignore_ws: bool = false)
                                                               *hz#RangeUniq()*

  Reduces a range of lines in a buffer and removes duplicate lines without
  changing the sort order of the lines. With [ignore_ws] specified, whitespace
  differences will be ignored.

  Ported from code by Damian Conway, originally presented in Scripting the Vim
  Editor, Part 4 at IBM developerWorks and on GitHub at:
  https://github.com/thoughtstream/Damian-Conway-s-Vim-Setup/blob/master/.vimrc#L1139-L1168

  Add mappings: >

      xnoremap q :call hz#range_uniq()<CR>
      xnoremap Q :call hz#range_uniq(v:true)<CR>
<

hz#xdg_base({type}, ...parts)                                   *hz#xdg_base()*
hz.XdgBase(type: string, parts: list<string> = []): string      *hz.XdgBase()*

  Returns a base XDG path for {type}, which must be one of `data`, `config`,
  or `cache`. Additional {parts} will be appended to the {type} path.

      Type      Value             Fallback~
      data      $XDG_DATA_HOME    $HOME/.local/share
      config    $XDG_CONFIG_HOME  $HOME/.config
      cache     $XDG_CACHE_HOME   $HOME/.cache

  An unrecognized {type} will result in an exception being thrown.

  This will produce results on Windows, but they will not be meaningful to
  how Windows directories are structured.

>
      call hz#xdg_base('data')        " => $HOME/.local/share
      call hz#xdg_base('data', 'vim') " => $HOME/.local/share/vim
<

hz#xdg_path({type}, ...parts)                                   *hz#xdg_path()*
hz.XdgPath(type: string, parts: list<string> = []): string       *hz.XdgPath()*

  Returns the XDG base path for {type} with `vim` and additional {parts}
  appended to the {type} path.

      Type      Value                 Fallback~
      data      $XDG_DATA_HOME/vim    $HOME/.local/share
      config    $XDG_CONFIG_HOME/vim  $HOME/.config
      cache     $XDG_CACHE_HOME/vim   $HOME/.cache
 
  This will produce results on Windows, but they will not be meaningful to how
  Windows directories are structured.

>
      call hz#xdg_path('data')        " => $HOME/.local/share/vim
      call hz#xdg_path('data', 'vim') " => $HOME/.local/share/vim/vim
<

hz#url_encode({url})                                          *hz#url_encode()*
hz.UrlEncode(url: string): string                              *hz#UrlEncode()*

  Encodes non-urlsafe values in {url} with percent hex-encoding (e.g.,
  ' ' becomes '%20'. Only the path and query parameters are encoded.

  Improves on a version ripped from haskellmode.vim by Andrew Radev (which
  encoded the entire URL).

hz#url_decode({url})                                          *hz#url_decode()*
hz#UrlDecode(url: string): string                              *hz#UrlDecode()*

  Decodes an encoded {url} back to plain-text.

  Based on a version ripped from unimpaired.vim by Andrew Radev.

==============================================================================
FUNCTIONAL FUNCTIONS                                     *hz.vim-fn-functions*

hz#fn#add({list}, {item})                                        *hz#fn#add()*
  Add {item} to a copy of {list}. See |add()|.

hz#fn#extend({expr1}, {expr2})                                *hz#fn#extend()*
  Merge {expr2} to a copy of {expr1}. See |extend()|.

hz#fn#filter({expr1}, {expr2})                                *hz#fn#filter()*
  Remove items from a copy of {expr1} using {expr2}. See |filter()|.

hz#fn#get({list}, {index}, [default])                            *hz#fn#get()*
  Get a copy of the item at {index} from |List| {list}, returning [default] if
  it is not available.

  See |get()|.

hz#fn#get({dict}, {key}, [default])
  Get an copy of the item with key {key} from |Dictionary| {dict}, returning
  [default] if it is not available.

  See |get()|.

hz#fn#get({func}, {what})
  Get an item {what} from Funcref {func}.

  See |get()|.

hz#fn#insert({list}, {item}, [index])                         *hz#fn#insert()*
  Insert {item} into a copy of {list}, at [index]. See |insert()|.
  [index] is 0 if omitted.

hz#fn#remove({list}, {idx}, [end])                            *hz#fn#remove()*
  Removes and returns a copy of the item at {idx} in {list}. If [end] is
  present, removes and returns a list containing a copy of the items from
  {idx} to [end].

  This function is similar to |remove()|, but has a different return signature
  (`[item, copy]` or `[[item, ...], copy]`) so that the immutability of the
  list or dictionary is maintained.

hz#fn#remove({dict}, {key})
  Returns and removes a copy of the item with the key {key} in {dict}.

  This function is similar to |remove()|, but has a different return signature
  (`[item, copy]` or `[[item, ...], copy]`) so that the immutability of the
  list or dictionary is maintained.

hz#fn#reverse({list})                                        *hz#fn#reverse()*
  Return a reversed copy of {list}. See |reverse()|.

hz#fn#sort({list}, [func], [dict])                              *hz#fn#sort()*
  Return a sorted copy of {list}. See |sort()|.

hz#fn#uniq({list}, [func], [dict])                              *hz#fn#uniq()*
  Return a copy of a list with second and succeeding copies of repeated
  adjacent list items in-place. See |uniq()|.

hz#fn#values({dict})                                          *hz#fn#values()*
  Return a copy of the values of {dict}. See |values()|.

  Note that there is no hz#fn#keys() because dictionary keys are essentially
  immutable in Vim as they can only be strings.

hz#fn#replace({list}, {idx}, {item})                         *hz#fn#replace()*
  Returns a copy of {list} where the item at {index} is a copy of {item}.


hz#fn#replace({dict}, {key}, {value})
  Returns a copy of {dict} where the item with key {key} is a copy of {item}.

hz#fn#pop({list}, {idx})                                         *hz#fn#pop()*
  Returns a copy of {list} where the item at {index} has been removed.


hz#fn#pop({dict}, {key})
  Returns a copy of {dict} where the item with key {key} has been removed.

hz#fn#wrap({expr})                                              *hz#fn#wrap()*
  If {expr} is a list, returns {expr}. Otherwise, it wraps {expr} in a list.

hz#fn#flatten({list...})                                     *hz#fn#flatten()*
  Return a flattened copy of {list...}.

hz#fn#map({expr1}, {expr2})                                      *hz#fn#map()*
  Returns a copy of {expr1} that has each item replaced with the result of
  evaluating {expr2}. See |map()|.

hz#fn#filter({expr1}, {expr2})                                *hz#fn#filter()*
  Returns a copy of {expr1} containing items where {expr2} is true. See
  |filter()|.

hz#fn#items({dict})                                            *hz#fn#items()*
  Returns a list with a copy of all the key-value pairs of {dict}. Each item
  is a list containing the key and the corresponding value. See |items()|.

hz#fn#reject({expr1}, {expr2})                                *hz#fn#reject()*
  Returns a copy of {expr1} containing items where {expr2} is false. See
  |filter()|.

hz#fn#reduce({expr}, [initial], {Fn})                         *hz#fn#reduce()*
  Loops over the items in {expr} (which must be a |List| or |Dictionary|) and
  executes {Fn}. If [initial] is not provided, the first item in {expr} is
  used as the initial value. The default [initial] value for a dictionary is
  an empty dictionary.

  When {expr} is empty, the [initial] value will be returned.

  {Fn} must be a function reference or lambda that returns the accumulator
  (`acc`) value. If {expr} is a |List|, {Fn} must accept two arguments (`val`
  and `acc`). If {expr} is a |Dict|, {Fn} must accept three arguments (`key`,
  `val`, and `acc`). Unlike |map()| and |filter()|, {Fn} may not be a string
  value (there is no easy way to simulate a `v:acc` parameter).

hz#fn#any({expr}, {Fn})                                          *hz#fn#any()*
  Loops over the items in {expr} and executes {Fn}, returning true if {Fn} is
  true for any value in {expr}. The value of {Fn} is the same as can be found
  for |filter()|.

  If {Fn} is a string that is not the name of a function, this function will
  be slower than if it is a function name or a function reference.

hz#fn#none({expr}, {Fn})                                        *hz#fn#none()*
  Loops over the items in {expr} and executes {Fn}, returning false if {Fn} is
  true for any value in {expr}. The value of {Fn} is the same as can be found
  for |filter()|.

  If {Fn} is a string that is not the name of a function, this function will
  be slower than if it is a function name or a function reference.

hz#fn#all({expr}, {Fn})                                          *hz#fn#all()*
  Loops over the items in {/expr} and executes {Fn}, returning false if {Fn}
  is false for any value in {expr}. The value of {Fn} is the same as can be
  found for |filter()|.

  If {Fn} is a string that is not the name of a function, this function will
  be slower than if it is a function name or a function reference.


==============================================================================
COMPATIBILITY                                           *hz.vim-compatibility*

All of the functions in Hz.vim are known to work with MacVim 9.1. They will
not work with any version of Neovim or Vim 8 or less due to the use of
|vim9script|.

==============================================================================
LICENCE                                                       *hz.vim-licence*

Hz.vim is public domain where possible, or licensed under CC0 1.0 where not.
There are no warranties, implied or expressed, about this Hz.vim or its
suitability or fitness for any particular purpose.

See https://creativecommons.org/publicdomain/zero/1.0/legalcode for more
information.

vim:tw=78:ts=8:ft=help:norl:
