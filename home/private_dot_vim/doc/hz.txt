*hz.txt*	Collected functions and commands for my vimrc              *hz*

Author: Austin Ziegler <halostatue@gmail.com>

==============================================================================
CONTENTS

  1. Introduction............................................|hz-introduction|
  2. Functions..................................................|hz-functions|
  3. Immutable Functions..............................|hz-immutable-functions|
  4. Compatibility..........................................|hz-compatibility|
  5. Licence......................................................|hz-licence|

==============================================================================
INTRODUCTION                                                  *hz-introduction*

Hz is a collection of functions and commands that power my vim configuration.
The latest version has been rewritten to use |vim9script| so they are only
compatible with Vim 9 or later.

==============================================================================
FUNCTIONS                                                   *hz-functions*

The Vim 9 script examples assume normal import into a |vim9script|. >

      import "hz.vim"
<

                                                *hz#platform()* *hz.Platform()*
hz#platform()
hz.Platform(): string

  Returns a |String| representing the underlying platform, resulting in
  a value of `windows`, `cygwin`, `mac`, or `unix`.

                                                            *hz#is()* *hz.Is()*
hz#is({type})
hz.Is({type}: string): bool

  Returns `true` if the tested {type} value is defined as true. Supported
  values for {type} are:

      Type              Condition~
      windows           |has| win16, win32, or win64
      cygwin            |has| win32unix
      mac               not windows or cygwin, |has| mac, macunix, gui_macvim,
                        or `uname` is `darwin` and does not have `xdg-open`
      macgui            is mac and has gui_running
      sudo              $SUDO_USER is set and is not $USER
      tmux              $TMUX is set

  Unrecognized values will always return `false`.

                                   *hz#valid_function()* *hz.IsValidFunction()*
hz#valid_function({value})
hz.IsValidFunction({value}: any): bool

  Report whether the {value} is a valid function (|t:v_func|) or function
  name (|t:v_string|). The function name may be a bare name (`fn`) or have
  parentheses at the end (`fn()`). When {value} is a |String| this is
  *similar* to `exists('*funcname')`.

                                                    *hz#mkpath()* *hz.Mkpath()*
hz#mkpath({path}, [force] = false)
hz.MKpath({path}: string, force: bool = false)

  Make {path}, prompting unless [force] is provided as `true`. {path} will be
  converted from |'encoding'| to |'termencoding'| with |iconv()|. Functionally
  equivalent to |mkdir()| with the `'p'` option.

                                                  *hz#isotime()* *hz.Isotime()*
hz#isotime([time])
hz.Isotime(time: number = null): string

  Portably produce a proper ISO 8601/RFC3339 timestamp. If [time] is not
  provided, the current |localtime()| will be used.

                                                          *hz#try()* *hz.Try()*
hz#try({Func}, {options} = {})
hz.Try(func: any, options: dict<any> = {}): any

  Tries to call the given function {Func} with the provided {options}. {Func}
  may be a |string| function name or a |Funcref|.

  Supported {options} are:

      Option    Default       Description~
      args      []            The arguments to pass to the |:call|ed function.
      dict      |null_dict|   The `self` parameter used if {Func} is
                              a |Dictionary-function|.
      default   |v:null|      The value to return if the function call fails.

  Try to call the given {Func} with an optional dictionary, default, and
  arguments. >

      hz#try('fugitive#statusline')
      hz#try(function('fugitive#statusline'))
      hz.Try('fugitive#statusline')
      hz.Try(function('fugitive#statusline'))
<

  If {Func} is a dictionary function (and not a partial function reference),
  the `self` must be provided with the `dict` option >

      hz#try('dict.Func', { 'dict': {} })
      hz.Try('dict.Func', { dict: {} })
<

  A `default` value may be provided in the {options}. >

      hz#try('F', { 'default': 'default' })
      hz.Try('F', { default: 'default' })
<

  Arguments are passed in `args` key of {options}. >

      hz#try('F', { 'args': [1, 2, 3] })
      hz.Try('F', { args: [1, 2, 3] })
<

  This function was originally by Tim Pope as part of Flagship.

                                                            *hz#in()* *hz.In()*
hz#in({haystack}, {needle})
hz.In(haystack: any, needle: any): bool

  Answers if {needle} can be found in the provided {haystack} which may be
  a |string|, |list|, or |dictionary|.

  If {haystack} is a |string|, {needle} must also be a |string| and is located
  in {haystack} with |stridx()|.

  If {haystack} is a |list|, {needle} is located with |index()|.

  If {haystack} is a |dictionary|, {needle} is located with |index| over the
  {haystack} |values()|.

  If {haystack} is any other type, the return value is `false`.

                                         *hz#trim_leading()* *hz.TrimLeading()*
hz#trim_leading({string}, [pattern])
hz.TrimLeading(string: string, pattern: string = '\_s'): string

  Trims leading [pattern] from {string}. [pattern] defaults to '\_s', the
  regex for whitespace and newlines.

                                       *hz#trim_trailing()* *hz.TrimTrailing()*
hz#trim_trailing({string}, [pattern])
hz.TrimTrailing(string: string, pattern: string = '\_s'): string
  Trims trailing [pattern] from {string}. [pattern] defaults to '\_s', the
  regex for whitespace and newlines.

                                                        *hz#trim()* *hz.Trim()*
hz#trim({string}, [pattern])
hz.Trim(string: string, pattern: string = '\_s'): string

  Trims both leading and trailing [pattern] from {string}. [pattern] defaults
  to '\_s', the regex for whitespace and newlines.

                                  *hz#execute_in_place()* *hz.ExecuteInPlace()*
hz#execute_in_place({command})
hz.ExecuteInPlace(cmd: string)

  Executes {command} while saving and restoring the window state.

                 *hz#execute_with_saved_search()* *hz.ExecuteWithSavedSearch()*
hz#execute_with_saved_search({command})
hz.ExecuteWithSavedSearch(cmd: string)

  Executes {command} with |hz.ExecuteInPlace| while saving and restoring the
  most recent saved search history.

                                 *hz#clean_whitespace()* *hz.CleanWhitespace()*
hz#clean_whitespace({line1}, {line2})
hz#CleanWhitespace(line1: any, line2: any)

  Clean trailing whitespace from the range provided. Search and window state
  are restored by using |hz.ExecuteWithSavedSearch()|.

                                           *hz#get_setting()* *hz.GetSetting()*
hz#get_setting({name}, [default])
hz.GetSetting(name: string, default: any = null): any

  Gets the value of a variable setting {name}, checking for a buffer override
  then a global value. That is, {name} will be checked from |b:|, then |g:|.
  A [default] value may be provided. >

  hz#get_setting('foo', false)
  get(b:, 'foo', get(g:, 'foo', false))
<

                                             *hz#get_motion()* *hz.GetMotion()*
hz#get_motion({motion})
hz.GetMotion(motion: string): string

  Execute the normal mode {motion} and return the text that it marks. For this
  to work, the {motion} must include a visual mode key (`V`, `v`, or `gv`).

  Both the 'z' register and the original cursor position will be restored
  after the text is yanked.

                                       *hz#switch_window()* *hz.SwitchWindow()*
hz#switch_window({bufname})
hz.SwitchWindow(bufname: string)

  Programmatically jump to the window identified by {bufname}.

                                             *hz#range_uniq()* *hz#RangeUniq()*
hz#range_uniq([ignore_ws]) range
hz.RangeUniq(line1: number, line2: number, ignore_ws: bool = false)

  Reduces a range of lines in a buffer and removes duplicate lines without
  changing the sort order of the lines. With [ignore_ws] specified, whitespace
  differences will be ignored.

  Ported from code by Damian Conway, originally presented in Scripting the Vim
  Editor, Part 4 at IBM developerWorks and on GitHub at:
  https://github.com/thoughtstream/Damian-Conway-s-Vim-Setup/blob/master/.vimrc#L1139-L1168

  Add mappings: >

      xnoremap q :call hz#range_uniq()<CR>
      xnoremap Q :call hz#range_uniq(v:true)<CR>
<

  The |autoload| version of this function is a range function (|func-range|)
  and implicitly receives the first and last line numbers. It is suitable for
  use with mappings, where the |vim9script| version is suitable for |command|
  ranges.

                                                 *hz#xdg_base()* *hz.XdgBase()*
hz#xdg_base({type}, {parts...})
hz.XdgBase(type: string, parts: list<string> = []): string

  Returns a base XDG path for {type}, which must be one of `data`, `config`,
  or `cache`. Additional {parts} will be appended to the {type} path.

      Type      Value             Fallback~
      data      $XDG_DATA_HOME    $HOME/.local/share
      config    $XDG_CONFIG_HOME  $HOME/.config
      cache     $XDG_CACHE_HOME   $HOME/.cache

  An unrecognized {type} will result in an exception being thrown.

  This will produce results on Windows, but they will not be meaningful to
  how Windows directories are structured. >

      call hz#xdg_base('data')        " => $HOME/.local/share
      call hz#xdg_base('data', 'vim') " => $HOME/.local/share/vim
<

                                                 *hz#xdg_path()* *hz.XdgPath()*
hz#xdg_path({type}, {parts...})
hz.XdgPath(type: string, parts: list<string> = []): string

  Returns the XDG base path for {type} with `vim` and additional {parts}
  appended to the {type} path.

      Type      Value                 Fallback~
      data      $XDG_DATA_HOME/vim    $HOME/.local/share
      config    $XDG_CONFIG_HOME/vim  $HOME/.config
      cache     $XDG_CACHE_HOME/vim   $HOME/.cache
 
  This will produce results on Windows, but they will not be meaningful to how
  Windows directories are structured. >

      call hz#xdg_path('data')        " => $HOME/.local/share/vim
      call hz#xdg_path('data', 'vim') " => $HOME/.local/share/vim/vim
<

                                             *hz#url_encode()* *hz#UrlEncode()*
hz#url_encode({url})
hz.UrlEncode(url: string): string

  Encodes non-urlsafe values in {url} with percent hex-encoding (e.g.,
  ' ' becomes '%20'. Only the path and query parameters are encoded.

  Improves on a version ripped from haskellmode.vim by Andrew Radev (which
  encoded the entire URL).

                                             *hz#url_decode()* *hz#UrlDecode()*
hz#url_decode({url})
hz#UrlDecode(url: string): string

  Decodes an encoded {url} back to plain-text.

  Based on a version ripped from unimpaired.vim by Andrew Radev.

                                                        *hz#wrap()* *hz#Wrap()*
hz#wrap({value})
hz#Wrap(value: any): list<any>

  If {value} is a |List|, it is returned unmodified. If not, it is returned
  wrapped in a |List|. >

        call hz#wrap(1) " => [1]
        call hz#wrap([10]) " => [10]
<

==============================================================================
IMMUTABLE FUNCTIONS                                    *hz-immutable-functions*

All of these functions operate on |copy()| or |deepcopy()| versions of their
arguments providing fully immutable data structure operations.

The Vim 9 script examples assume normal import into a |vim9script|. >

      import "hz/immutable.vim"
<

hz#immutable#add({object}, {expr})                         *hz#immutable#add()*
immutable.Add(object: any, expr: any): any                    *immutable.Add()*

  Append item {expr} to a copy of |List| or |Blob| {object} and return the
  resulting List or Blob. See |add()|.

                                   *hz#immutable#extend()* *immutable.Extend()*
hz#immutable#extend({expr1}, {expr2}, {expr3} = v:null)
immutable.Extend(expr1: any, expr2: any, expr3: any = null)

  {expr1} and {expr2} must be both |Lists| or both |Dictionaries|. See
  |extend()|.

  If they are |Lists|: Append a copy of {expr2} to a copy of {expr1},
  returning a new list (similar to |extendnew()|). If {expr3} is given insert
  the items of {expr2} before the item with index {expr3} in {expr1}. When
  {expr3} is zero insert before the first item. When {expr3} is equal to
  len({expr1}) then {expr2} is appended.

  If they are |Dictionaries|: Add copies of all entries from {expr2} to
  a copy of {expr1}. If a key exists in both {expr1} and {expr2} then {expr3}
  is used to decide what to do:

        {expr3} value       Meaning~
        "keep"              keep the value from {expr1}
        "force"             use the value from {expr2} (default)
        "error"             give error message |E737|

                                   *hz#immutable#filter()* *immutable.Filter()*
hz#immutable#filter({expr1}, {expr2})
immutable.Filter(expr1: any, expr2: any): any

  Remove items from a copy of {expr1} using {expr2}. See |filter()|.

                                         *hz#immutable#get()* *immutable.Get()*
hz#immutable#get({expr}, {index}, [default] = v:null)
immutable.Get({expr}, {index}, default = null): any

  Get a copy of the item at {index} from {expr}, returning [default] if it is
  not available. See |get()|.

                                   *hz#immutable#insert()* *immutable.Insert()*
hz#immutable#insert({object}, {item}, [idx] = 0)
immutable.Insert(object: any, item: any, idx: number = 0)

  Insert {item} into a copy of {list}, at [idx]. See |insert()|.

                                   *hz#immutable#remove()* *immutable.Remove()*
hz#immutable#remove({object}, {idx}, [end])
immutable.Remove(object: any, index: any, endval: any = null): list<any>

  Removes an item at {idx} from a copy of {object}, or from {idx} to [end].
  This returns a two-item tuple list, the item and the modified list. This
  function is similar to |remove()|, but differs in the return value. >

        let mylist = [1, 2, 3]
        hz#immutable#remove(mylist, -1) " [3, [1, 2]]
<

  To remove an item from object without getting its value, use
  |immutable.RemoveItem()|.


                                 *hz#immutable#reverse()* *immutable.Reverse()*
hz#immutable#reverse({object})
immutable.Reverse(object: any): any

  Return a reversed copy of {object}. See |reverse()|.

                                       *hz#immutable#sort()* *immutable.Sort()*
hz#immutable#sort({list}, [how] = v:null, [dict] = v:null)
immutable.Sort(list: list<any>, how: any = null, dict: dict<any> = null_dict): list<any>

  Return a sorted copy of {list} using [how] and optionally [dict] if [how] is
  a dictionary function. See |sort()|.

                                       *hz#immutable#uniq()* *immutable.Uniq()*
hz#immutable#uniq({list}, [func], [dict])
immutable.Uniq(list: list<any>, func: any = null, dict: dict<any> = null_dict): list<any>

  Return a copy of a {list} where repeated items in {list} have been removed.
  See |uniq()|.

                                       *hz#immutable#keys()* *immutable.Keys()*
hz#immutable#keys({dict})
immutable.Keys(dict: dict<any>): list<string>

  Return a copy of the |List| of all keys of {dict}. The |List| is in
  arbitrary order. See |keys()|.

                                   *hz#immutable#values()* *immutable.Values()*
hz#immutable#values({dict})
immutable.Values(dict: dict<any>): list<any>

  Return a copy of the |List| of all values of {dict}. The |List| is in
  arbitrary order. See |values()|.

                                     *hz#immutable#items()* *immutable.Items()*
hz#immutable#items({dict})
immutable.Items(dict: any): list<list<any>>

  Returns a deep copy of the |List| of all key-value pairs of {dict}. Each
  |List| item is a list with two items: the key of a {dict} entry and the
  value of this entry. The |List| is in arbitrary order. See |items()|.

  If {dict} is a |List| or |String| argument, the resulting pairs will be the
  index and value at the index. >

      echo immutable.Items('hello')
      [[0, 'h'], [1, 'e'], [2, 'l'], [3, 'l'], [4, 'o']]
<

                                 *hz#immutable#replace()* *immutable.Replace()*
hz#immutable#replace({object}, {idx}, {value})
immutable.Replace(object: any, idx: any, value: any): any

  Replaces the item at {idx} in a copy of {object} with a copy of {vlaue}. >

      var list = [1, 2, 3]
      var newList = immutable.Replace(list, 2, 5)
      echo list         # [1, 2, 3]
      echo newList      # [1, 5, 3]
<

                          *hz#immutable#remove_item()* *immutable.RemoveItem()*
hz#immutable#remove_item({object}, {idx})
immutable.RemoveItem(object: any, idx: any): any

  Returns a copy of {object} where the item at {idx} has been removed.

                                       *hz#immutable#wrap()* *immutable.Wrap()*
hz#immutable#wrap({expr})
immutable.Wrap(expr: any): any

  If {expr} is a |List|, returns a copy of {expr}, otherwise it wraps a copy
  of {expr} in a list. See |hz#wrap()|.

                                 *hz#immutable#flatten()* *immutable.Flatten()*
hz#immutable#flatten({list}, [maxdepth])
immutable.Flatten(list: list<any>, maxdepth: number = null)

  A wrapper around |flattennew()| operating on a |deepcopy()| of {list}.

                                         *hz#immutable#map()* *immutable.Map()*
hz#immutable#map({expr1}, {expr2})
immutable.Map(expr1: any, expr2: any): any

  A wrapper around |mapnew()| operating on a |deepcopy()| of {expr1}.

                                   *hz#immutable#filter()* *immutable.Filter()*
hz#immutable#filter({expr1}, {expr2})
immutable.Filter(expr1: any, expr2: any): any

  A wrapper around |filter()| operating on a |deepcopy()| of {expr1}.

                                   *hz#immutable#reject()* *immutable.Reject()*
hz#immutable#reject({expr1}, {expr2})
immutable.Reject(expr1: any, expr2: any): any

  A wrapper around |filter()| operating on a |deepcopy()| of {expr1} where
  {expr2} is false.

                                   *hz#immutable#reduce()* *immutable.Reduce()*
hz#immutable#reduce({expr}, [initial], {fn})
immutable.Reduce(expr: any, initial: any, fn: any = null): any

  Loops over the items in a copy of {expr} and executes {fn} on each item,
  accumulating the result. If [initial] is not provided, the first item in
  {expr} is used as the initial value, or an empty dictionary (`{}`) if {expr}
  is a |dictionary|. When {expr} is empty, the [initial] value will be
  returned.

  {fn} must be a function reference or lambda that accepts two or three
  arguments and returns the accumulator value. For non-|dictionary| {expr}
  values, the two-argument version accepts the value and the accumulator: >

        (value: any, acc: any): any => acc * value
<

  If {expr} is a dictionary, the two-argument version is a two-element |List|
  where the elements are the key and value as produced from |items()| and the
  accumulator: >

        (pair: list<any>, acc: any): any => acc[pair[1]] = pair[0]
<

  The three-argument version always provides the key/index and value with the
  accumulator: >

        (key: string, value: any, acc: any): any => acc[value] = key
        (idx: number, value: any, acc: any): any => acc[value] = idx
<

                                         *hz#immutable#any()* *immutable.Any()*
hz#immutable#any({expr}, {fn})
immutable.any(expr: any, fn: any): bool

  Loops over the items in a copy of {expr} and executes {fn}, returning true
  if {fn} is true for any value in {expr}. The value of {fn} is the same as
  can be found for |filter()|.

  If {expr} is |empty()|, the return value is `false`.

  If {fn} is a string that is not the name of a function, this function will
  be slower than if it is a function name or a function reference.

  When {fn} is a function, it may accept one or two arguments and must return
  a boolean value. For non-|dictionary| {expr} values, the one-argument
  version accepts the value: >

        (value: any): bool => value->length() > 5
<

  If {expr} is a |dictionary|, the one-argument version is a two-element
  |List| where the elements are the key and value: >

        (pair: list<any>): bool => (pair[0]->length() + pair[1]->length()) > 7
<

  The two-argument version always provides the key/index and value with the
  accumulator: >

        (key: string, value: any): bool => key->length() > 3 && value->length() > 3
        (idx: number, value: any): bool => idx > 5 && value->length() > 3
<

                                       *hz#immutable#none()* *immutable.None()*
hz#immutable#none({expr}, {fn})
immutable.None(expr: any, fn: any): bool

  A complementary of |immutable.Any()| which only returns true if none of the
  items in {expr} pass the test in {fn}. If {expr} is |empty()|, the return
  value is `true`.

                                         *hz#immutable#all()* *immutable.all()*
hz#immutable#all({expr}, {Fn})
immutable.All(expr: any, fn: any): bool

  A complement to |immutable.Any()| which only returns true if all of the
  items in {expr} pass the test in {fn}. If {expr} is |empty()|, the return
  value is `true`.


==============================================================================
COMPATIBILITY                                                *hz-compatibility*

All of the functions in Hz are known to work with MacVim 9.1. They will not
work with any version of Neovim or Vim 8 or less due to the use of
|vim9script|.

==============================================================================
LICENCE                                                            *hz-licence*

Hz is public domain where possible, or licensed under CC0 1.0 where not. There
are no warranties, implied or expressed, about this Hz or its suitability or
fitness for any particular purpose.

See https://creativecommons.org/publicdomain/zero/1.0/legalcode for more
information.

vim:tw=78:ts=8:ft=help:norl:
